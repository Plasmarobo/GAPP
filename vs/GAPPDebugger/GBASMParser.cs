//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from GBASM.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class GBASMParser : Parser {
	public const int
		Letters=1, Z=2, A=3, B=4, C=5, D=6, E=7, F=8, H=9, L=10, AF=11, BC=12, 
		DE=13, HL=14, SP=15, NZ=16, NC=17, RST_VALUE=18, RST_DIGITS=19, Label=20, 
		Integer=21, Hexval=22, Neg=23, Plus=24, HLplus=25, HLminus=26, MEMSTART=27, 
		MEMEND=28, LD=29, JR=30, JP=31, OR=32, CP=33, RL=34, RR=35, DI=36, EI=37, 
		LDD=38, LDI=39, ADD=40, ADC=41, SBC=42, BIT=43, RES=44, SET=45, RET=46, 
		INC=47, DEC=48, SUB=49, AND=50, XOR=51, RLC=52, RRC=53, POP=54, SLA=55, 
		SRA=56, SRL=57, NOP=58, RLA=59, RRA=60, DAA=61, CPL=62, SCF=63, CCF=64, 
		LDH=65, RST=66, CALL=67, PUSH=68, SWAP=69, RLCA=70, RRCA=71, STOP=72, 
		HALT=73, RETI=74, Separator=75, WS=76, Comment=77;
	public const int
		RULE_eval = 0, RULE_exp = 1, RULE_op = 2, RULE_jumpflag = 3, RULE_complexop = 4, 
		RULE_cmd = 5, RULE_regop = 6, RULE_flagop = 7, RULE_complex = 8, RULE_loc = 9, 
		RULE_memory = 10, RULE_offset = 11, RULE_register = 12, RULE_wideregister = 13, 
		RULE_flag = 14, RULE_value = 15, RULE_negvalue = 16;
	public static readonly string[] ruleNames = {
		"eval", "exp", "op", "jumpflag", "complexop", "cmd", "regop", "flagop", 
		"complex", "loc", "memory", "offset", "register", "wideregister", "flag", 
		"value", "negvalue"
	};

	private static readonly string[] _LiteralNames = {
		null, null, "'Z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'H'", "'L'", 
		"'AF'", "'BC'", "'DE'", "'HL'", "'SP'", "'NZ'", "'NC'", null, null, null, 
		null, null, "'-'", "'+'", null, null, "'('", "')'", null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, "','"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Letters", "Z", "A", "B", "C", "D", "E", "F", "H", "L", "AF", "BC", 
		"DE", "HL", "SP", "NZ", "NC", "RST_VALUE", "RST_DIGITS", "Label", "Integer", 
		"Hexval", "Neg", "Plus", "HLplus", "HLminus", "MEMSTART", "MEMEND", "LD", 
		"JR", "JP", "OR", "CP", "RL", "RR", "DI", "EI", "LDD", "LDI", "ADD", "ADC", 
		"SBC", "BIT", "RES", "SET", "RET", "INC", "DEC", "SUB", "AND", "XOR", 
		"RLC", "RRC", "POP", "SLA", "SRA", "SRL", "NOP", "RLA", "RRA", "DAA", 
		"CPL", "SCF", "CCF", "LDH", "RST", "CALL", "PUSH", "SWAP", "RLCA", "RRCA", 
		"STOP", "HALT", "RETI", "Separator", "WS", "Comment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GBASM.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GBASMParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class EvalContext : ParserRuleContext {
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(GBASMParser.Eof, 0); }
		public EvalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eval; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterEval(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitEval(this);
		}
	}

	[RuleVersion(0)]
	public EvalContext eval() {
		EvalContext _localctx = new EvalContext(Context, State);
		EnterRule(_localctx, 0, RULE_eval);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 34; exp();
			State = 35; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpContext : ParserRuleContext {
		public OpContext op() {
			return GetRuleContext<OpContext>(0);
		}
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ExpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterExp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitExp(this);
		}
	}

	[RuleVersion(0)]
	public ExpContext exp() {
		ExpContext _localctx = new ExpContext(Context, State);
		EnterRule(_localctx, 2, RULE_exp);
		try {
			State = 41;
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 37; op();
				State = 38; exp();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 40; op();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpContext : ParserRuleContext {
		public CmdContext cmd() {
			return GetRuleContext<CmdContext>(0);
		}
		public RegopContext regop() {
			return GetRuleContext<RegopContext>(0);
		}
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public WideregisterContext wideregister() {
			return GetRuleContext<WideregisterContext>(0);
		}
		public MemoryContext memory() {
			return GetRuleContext<MemoryContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public JumpflagContext jumpflag() {
			return GetRuleContext<JumpflagContext>(0);
		}
		public ComplexopContext complexop() {
			return GetRuleContext<ComplexopContext>(0);
		}
		public OpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitOp(this);
		}
	}

	[RuleVersion(0)]
	public OpContext op() {
		OpContext _localctx = new OpContext(Context, State);
		EnterRule(_localctx, 4, RULE_op);
		try {
			State = 53;
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 43; cmd();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 44; regop();
				State = 49;
				switch (TokenStream.La(1)) {
				case A:
				case B:
				case C:
				case D:
				case E:
				case F:
				case H:
				case L:
					{
					State = 45; register();
					}
					break;
				case AF:
				case BC:
				case DE:
				case HL:
				case SP:
					{
					State = 46; wideregister();
					}
					break;
				case MEMSTART:
					{
					State = 47; memory();
					}
					break;
				case Integer:
				case Hexval:
					{
					State = 48; value();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 51; jumpflag();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 52; complexop();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpflagContext : ParserRuleContext {
		public FlagopContext flagop() {
			return GetRuleContext<FlagopContext>(0);
		}
		public MemoryContext memory() {
			return GetRuleContext<MemoryContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ITerminalNode Label() { return GetToken(GBASMParser.Label, 0); }
		public FlagContext flag() {
			return GetRuleContext<FlagContext>(0);
		}
		public ITerminalNode Separator() { return GetToken(GBASMParser.Separator, 0); }
		public JumpflagContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jumpflag; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterJumpflag(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitJumpflag(this);
		}
	}

	[RuleVersion(0)]
	public JumpflagContext jumpflag() {
		JumpflagContext _localctx = new JumpflagContext(Context, State);
		EnterRule(_localctx, 6, RULE_jumpflag);
		try {
			State = 70;
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 55; flagop();
				State = 60;
				switch (TokenStream.La(1)) {
				case MEMSTART:
					{
					State = 56; memory();
					}
					break;
				case Integer:
				case Hexval:
					{
					State = 57; value();
					}
					break;
				case Label:
					{
					State = 58; Match(Label);
					}
					break;
				case Z:
				case C:
				case NZ:
				case NC:
					{
					State = 59; flag();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 62; flagop();
				State = 63; flag();
				State = 64; Match(Separator);
				State = 68;
				switch (TokenStream.La(1)) {
				case MEMSTART:
					{
					State = 65; memory();
					}
					break;
				case Integer:
				case Hexval:
					{
					State = 66; value();
					}
					break;
				case Label:
					{
					State = 67; Match(Label);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexopContext : ParserRuleContext {
		public ComplexContext complex() {
			return GetRuleContext<ComplexContext>(0);
		}
		public LocContext[] loc() {
			return GetRuleContexts<LocContext>();
		}
		public LocContext loc(int i) {
			return GetRuleContext<LocContext>(i);
		}
		public ITerminalNode Separator() { return GetToken(GBASMParser.Separator, 0); }
		public ComplexopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complexop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterComplexop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitComplexop(this);
		}
	}

	[RuleVersion(0)]
	public ComplexopContext complexop() {
		ComplexopContext _localctx = new ComplexopContext(Context, State);
		EnterRule(_localctx, 8, RULE_complexop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 72; complex();
			State = 73; loc();
			State = 74; Match(Separator);
			State = 75; loc();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CmdContext : ParserRuleContext {
		public ITerminalNode NOP() { return GetToken(GBASMParser.NOP, 0); }
		public ITerminalNode RLCA() { return GetToken(GBASMParser.RLCA, 0); }
		public ITerminalNode RRCA() { return GetToken(GBASMParser.RRCA, 0); }
		public ITerminalNode STOP() { return GetToken(GBASMParser.STOP, 0); }
		public ITerminalNode RLA() { return GetToken(GBASMParser.RLA, 0); }
		public ITerminalNode RRA() { return GetToken(GBASMParser.RRA, 0); }
		public ITerminalNode DAA() { return GetToken(GBASMParser.DAA, 0); }
		public ITerminalNode CPL() { return GetToken(GBASMParser.CPL, 0); }
		public ITerminalNode SCF() { return GetToken(GBASMParser.SCF, 0); }
		public ITerminalNode CCF() { return GetToken(GBASMParser.CCF, 0); }
		public ITerminalNode HALT() { return GetToken(GBASMParser.HALT, 0); }
		public ITerminalNode RETI() { return GetToken(GBASMParser.RETI, 0); }
		public ITerminalNode DI() { return GetToken(GBASMParser.DI, 0); }
		public ITerminalNode EI() { return GetToken(GBASMParser.EI, 0); }
		public ITerminalNode RST() { return GetToken(GBASMParser.RST, 0); }
		public ITerminalNode RET() { return GetToken(GBASMParser.RET, 0); }
		public CmdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cmd; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterCmd(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitCmd(this);
		}
	}

	[RuleVersion(0)]
	public CmdContext cmd() {
		CmdContext _localctx = new CmdContext(Context, State);
		EnterRule(_localctx, 10, RULE_cmd);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			_la = TokenStream.La(1);
			if ( !(((((_la - 36)) & ~0x3f) == 0 && ((1L << (_la - 36)) & ((1L << (DI - 36)) | (1L << (EI - 36)) | (1L << (RET - 36)) | (1L << (NOP - 36)) | (1L << (RLA - 36)) | (1L << (RRA - 36)) | (1L << (DAA - 36)) | (1L << (CPL - 36)) | (1L << (SCF - 36)) | (1L << (CCF - 36)) | (1L << (RST - 36)) | (1L << (RLCA - 36)) | (1L << (RRCA - 36)) | (1L << (STOP - 36)) | (1L << (HALT - 36)) | (1L << (RETI - 36)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegopContext : ParserRuleContext {
		public ITerminalNode INC() { return GetToken(GBASMParser.INC, 0); }
		public ITerminalNode DEC() { return GetToken(GBASMParser.DEC, 0); }
		public ITerminalNode SUB() { return GetToken(GBASMParser.SUB, 0); }
		public ITerminalNode AND() { return GetToken(GBASMParser.AND, 0); }
		public ITerminalNode XOR() { return GetToken(GBASMParser.XOR, 0); }
		public ITerminalNode OR() { return GetToken(GBASMParser.OR, 0); }
		public ITerminalNode CP() { return GetToken(GBASMParser.CP, 0); }
		public ITerminalNode POP() { return GetToken(GBASMParser.POP, 0); }
		public ITerminalNode PUSH() { return GetToken(GBASMParser.PUSH, 0); }
		public ITerminalNode RLC() { return GetToken(GBASMParser.RLC, 0); }
		public ITerminalNode RRC() { return GetToken(GBASMParser.RRC, 0); }
		public ITerminalNode RL() { return GetToken(GBASMParser.RL, 0); }
		public ITerminalNode RR() { return GetToken(GBASMParser.RR, 0); }
		public ITerminalNode SLA() { return GetToken(GBASMParser.SLA, 0); }
		public ITerminalNode SRA() { return GetToken(GBASMParser.SRA, 0); }
		public ITerminalNode SWAP() { return GetToken(GBASMParser.SWAP, 0); }
		public ITerminalNode SRL() { return GetToken(GBASMParser.SRL, 0); }
		public RegopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterRegop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitRegop(this);
		}
	}

	[RuleVersion(0)]
	public RegopContext regop() {
		RegopContext _localctx = new RegopContext(Context, State);
		EnterRule(_localctx, 12, RULE_regop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 79;
			_la = TokenStream.La(1);
			if ( !(((((_la - 32)) & ~0x3f) == 0 && ((1L << (_la - 32)) & ((1L << (OR - 32)) | (1L << (CP - 32)) | (1L << (RL - 32)) | (1L << (RR - 32)) | (1L << (INC - 32)) | (1L << (DEC - 32)) | (1L << (SUB - 32)) | (1L << (AND - 32)) | (1L << (XOR - 32)) | (1L << (RLC - 32)) | (1L << (RRC - 32)) | (1L << (POP - 32)) | (1L << (SLA - 32)) | (1L << (SRA - 32)) | (1L << (SRL - 32)) | (1L << (PUSH - 32)) | (1L << (SWAP - 32)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlagopContext : ParserRuleContext {
		public ITerminalNode RET() { return GetToken(GBASMParser.RET, 0); }
		public ITerminalNode JR() { return GetToken(GBASMParser.JR, 0); }
		public ITerminalNode JP() { return GetToken(GBASMParser.JP, 0); }
		public ITerminalNode CALL() { return GetToken(GBASMParser.CALL, 0); }
		public FlagopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flagop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterFlagop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitFlagop(this);
		}
	}

	[RuleVersion(0)]
	public FlagopContext flagop() {
		FlagopContext _localctx = new FlagopContext(Context, State);
		EnterRule(_localctx, 14, RULE_flagop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81;
			_la = TokenStream.La(1);
			if ( !(((((_la - 30)) & ~0x3f) == 0 && ((1L << (_la - 30)) & ((1L << (JR - 30)) | (1L << (JP - 30)) | (1L << (RET - 30)) | (1L << (CALL - 30)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComplexContext : ParserRuleContext {
		public ITerminalNode LD() { return GetToken(GBASMParser.LD, 0); }
		public ITerminalNode LDD() { return GetToken(GBASMParser.LDD, 0); }
		public ITerminalNode LDI() { return GetToken(GBASMParser.LDI, 0); }
		public ITerminalNode LDH() { return GetToken(GBASMParser.LDH, 0); }
		public ITerminalNode ADD() { return GetToken(GBASMParser.ADD, 0); }
		public ITerminalNode ADC() { return GetToken(GBASMParser.ADC, 0); }
		public ITerminalNode SBC() { return GetToken(GBASMParser.SBC, 0); }
		public ITerminalNode BIT() { return GetToken(GBASMParser.BIT, 0); }
		public ITerminalNode RES() { return GetToken(GBASMParser.RES, 0); }
		public ITerminalNode SET() { return GetToken(GBASMParser.SET, 0); }
		public ComplexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_complex; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterComplex(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitComplex(this);
		}
	}

	[RuleVersion(0)]
	public ComplexContext complex() {
		ComplexContext _localctx = new ComplexContext(Context, State);
		EnterRule(_localctx, 16, RULE_complex);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 83;
			_la = TokenStream.La(1);
			if ( !(((((_la - 29)) & ~0x3f) == 0 && ((1L << (_la - 29)) & ((1L << (LD - 29)) | (1L << (LDD - 29)) | (1L << (LDI - 29)) | (1L << (ADD - 29)) | (1L << (ADC - 29)) | (1L << (SBC - 29)) | (1L << (BIT - 29)) | (1L << (RES - 29)) | (1L << (SET - 29)) | (1L << (LDH - 29)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LocContext : ParserRuleContext {
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public WideregisterContext wideregister() {
			return GetRuleContext<WideregisterContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext negvalue() {
			return GetRuleContext<NegvalueContext>(0);
		}
		public FlagContext flag() {
			return GetRuleContext<FlagContext>(0);
		}
		public OffsetContext offset() {
			return GetRuleContext<OffsetContext>(0);
		}
		public ITerminalNode Label() { return GetToken(GBASMParser.Label, 0); }
		public MemoryContext memory() {
			return GetRuleContext<MemoryContext>(0);
		}
		public LocContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loc; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterLoc(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitLoc(this);
		}
	}

	[RuleVersion(0)]
	public LocContext loc() {
		LocContext _localctx = new LocContext(Context, State);
		EnterRule(_localctx, 18, RULE_loc);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 93;
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				{
				State = 85; register();
				}
				break;
			case 2:
				{
				State = 86; wideregister();
				}
				break;
			case 3:
				{
				State = 87; value();
				}
				break;
			case 4:
				{
				State = 88; negvalue();
				}
				break;
			case 5:
				{
				State = 89; flag();
				}
				break;
			case 6:
				{
				State = 90; offset();
				}
				break;
			case 7:
				{
				State = 91; Match(Label);
				}
				break;
			case 8:
				{
				State = 92; memory();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemoryContext : ParserRuleContext {
		public ITerminalNode MEMSTART() { return GetToken(GBASMParser.MEMSTART, 0); }
		public ITerminalNode MEMEND() { return GetToken(GBASMParser.MEMEND, 0); }
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public WideregisterContext wideregister() {
			return GetRuleContext<WideregisterContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public MemoryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memory; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterMemory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitMemory(this);
		}
	}

	[RuleVersion(0)]
	public MemoryContext memory() {
		MemoryContext _localctx = new MemoryContext(Context, State);
		EnterRule(_localctx, 20, RULE_memory);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 95; Match(MEMSTART);
			State = 99;
			switch (TokenStream.La(1)) {
			case A:
			case B:
			case C:
			case D:
			case E:
			case F:
			case H:
			case L:
				{
				State = 96; register();
				}
				break;
			case AF:
			case BC:
			case DE:
			case HL:
			case SP:
				{
				State = 97; wideregister();
				}
				break;
			case Integer:
			case Hexval:
				{
				State = 98; value();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 101; Match(MEMEND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OffsetContext : ParserRuleContext {
		public ITerminalNode Plus() { return GetToken(GBASMParser.Plus, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public WideregisterContext wideregister() {
			return GetRuleContext<WideregisterContext>(0);
		}
		public NegvalueContext negvalue() {
			return GetRuleContext<NegvalueContext>(0);
		}
		public OffsetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_offset; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterOffset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitOffset(this);
		}
	}

	[RuleVersion(0)]
	public OffsetContext offset() {
		OffsetContext _localctx = new OffsetContext(Context, State);
		EnterRule(_localctx, 22, RULE_offset);
		try {
			State = 116;
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 105;
				switch (TokenStream.La(1)) {
				case A:
				case B:
				case C:
				case D:
				case E:
				case F:
				case H:
				case L:
					{
					State = 103; register();
					}
					break;
				case AF:
				case BC:
				case DE:
				case HL:
				case SP:
					{
					State = 104; wideregister();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 107; Match(Plus);
				State = 108; value();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 112;
				switch (TokenStream.La(1)) {
				case A:
				case B:
				case C:
				case D:
				case E:
				case F:
				case H:
				case L:
					{
					State = 110; register();
					}
					break;
				case AF:
				case BC:
				case DE:
				case HL:
				case SP:
					{
					State = 111; wideregister();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 114; negvalue();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegisterContext : ParserRuleContext {
		public ITerminalNode A() { return GetToken(GBASMParser.A, 0); }
		public ITerminalNode B() { return GetToken(GBASMParser.B, 0); }
		public ITerminalNode C() { return GetToken(GBASMParser.C, 0); }
		public ITerminalNode D() { return GetToken(GBASMParser.D, 0); }
		public ITerminalNode E() { return GetToken(GBASMParser.E, 0); }
		public ITerminalNode F() { return GetToken(GBASMParser.F, 0); }
		public ITerminalNode H() { return GetToken(GBASMParser.H, 0); }
		public ITerminalNode L() { return GetToken(GBASMParser.L, 0); }
		public RegisterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_register; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterRegister(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitRegister(this);
		}
	}

	[RuleVersion(0)]
	public RegisterContext register() {
		RegisterContext _localctx = new RegisterContext(Context, State);
		EnterRule(_localctx, 24, RULE_register);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 118;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A) | (1L << B) | (1L << C) | (1L << D) | (1L << E) | (1L << F) | (1L << H) | (1L << L))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WideregisterContext : ParserRuleContext {
		public ITerminalNode AF() { return GetToken(GBASMParser.AF, 0); }
		public ITerminalNode BC() { return GetToken(GBASMParser.BC, 0); }
		public ITerminalNode DE() { return GetToken(GBASMParser.DE, 0); }
		public ITerminalNode HL() { return GetToken(GBASMParser.HL, 0); }
		public ITerminalNode SP() { return GetToken(GBASMParser.SP, 0); }
		public WideregisterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_wideregister; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterWideregister(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitWideregister(this);
		}
	}

	[RuleVersion(0)]
	public WideregisterContext wideregister() {
		WideregisterContext _localctx = new WideregisterContext(Context, State);
		EnterRule(_localctx, 26, RULE_wideregister);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 120;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AF) | (1L << BC) | (1L << DE) | (1L << HL) | (1L << SP))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlagContext : ParserRuleContext {
		public ITerminalNode NZ() { return GetToken(GBASMParser.NZ, 0); }
		public ITerminalNode NC() { return GetToken(GBASMParser.NC, 0); }
		public ITerminalNode Z() { return GetToken(GBASMParser.Z, 0); }
		public ITerminalNode C() { return GetToken(GBASMParser.C, 0); }
		public FlagContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flag; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterFlag(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitFlag(this);
		}
	}

	[RuleVersion(0)]
	public FlagContext flag() {
		FlagContext _localctx = new FlagContext(Context, State);
		EnterRule(_localctx, 28, RULE_flag);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Z) | (1L << C) | (1L << NZ) | (1L << NC))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		public ITerminalNode Hexval() { return GetToken(GBASMParser.Hexval, 0); }
		public ITerminalNode Integer() { return GetToken(GBASMParser.Integer, 0); }
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitValue(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(Context, State);
		EnterRule(_localctx, 30, RULE_value);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			_la = TokenStream.La(1);
			if ( !(_la==Integer || _la==Hexval) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NegvalueContext : ParserRuleContext {
		public ITerminalNode Neg() { return GetToken(GBASMParser.Neg, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negvalue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterNegvalue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitNegvalue(this);
		}
	}

	[RuleVersion(0)]
	public NegvalueContext negvalue() {
		NegvalueContext _localctx = new NegvalueContext(Context, State);
		EnterRule(_localctx, 32, RULE_negvalue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 126; Match(Neg);
			State = 127; value();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3O\x84\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3"+
		"\x3\x5\x3,\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4\x34\n\x4\x3"+
		"\x4\x3\x4\x5\x4\x38\n\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5?\n\x5\x3"+
		"\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5G\n\x5\x5\x5I\n\x5\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\a\x3\a\x3\b\x3\b\x3\t\x3\t\x3\n\x3\n\x3\v\x3\v\x3"+
		"\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v`\n\v\x3\f\x3\f\x3\f\x3\f\x5\f\x66\n\f"+
		"\x3\f\x3\f\x3\r\x3\r\x5\rl\n\r\x3\r\x3\r\x3\r\x3\r\x3\r\x5\rs\n\r\x3\r"+
		"\x3\r\x5\rw\n\r\x3\xE\x3\xE\x3\xF\x3\xF\x3\x10\x3\x10\x3\x11\x3\x11\x3"+
		"\x12\x3\x12\x3\x12\x3\x12\x2\x2\x13\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16"+
		"\x18\x1A\x1C\x1E \"\x2\n\a\x2&\'\x30\x30<\x42\x44\x44HL\x5\x2\"%\x31;"+
		"\x46G\x5\x2 !\x30\x30\x45\x45\x5\x2\x1F\x1F(/\x43\x43\x3\x2\x5\f\x3\x2"+
		"\r\x11\x5\x2\x4\x4\a\a\x12\x13\x3\x2\x17\x18\x8B\x2$\x3\x2\x2\x2\x4+\x3"+
		"\x2\x2\x2\x6\x37\x3\x2\x2\x2\bH\x3\x2\x2\x2\nJ\x3\x2\x2\x2\fO\x3\x2\x2"+
		"\x2\xEQ\x3\x2\x2\x2\x10S\x3\x2\x2\x2\x12U\x3\x2\x2\x2\x14_\x3\x2\x2\x2"+
		"\x16\x61\x3\x2\x2\x2\x18v\x3\x2\x2\x2\x1Ax\x3\x2\x2\x2\x1Cz\x3\x2\x2\x2"+
		"\x1E|\x3\x2\x2\x2 ~\x3\x2\x2\x2\"\x80\x3\x2\x2\x2$%\x5\x4\x3\x2%&\a\x2"+
		"\x2\x3&\x3\x3\x2\x2\x2\'(\x5\x6\x4\x2()\x5\x4\x3\x2),\x3\x2\x2\x2*,\x5"+
		"\x6\x4\x2+\'\x3\x2\x2\x2+*\x3\x2\x2\x2,\x5\x3\x2\x2\x2-\x38\x5\f\a\x2"+
		".\x33\x5\xE\b\x2/\x34\x5\x1A\xE\x2\x30\x34\x5\x1C\xF\x2\x31\x34\x5\x16"+
		"\f\x2\x32\x34\x5 \x11\x2\x33/\x3\x2\x2\x2\x33\x30\x3\x2\x2\x2\x33\x31"+
		"\x3\x2\x2\x2\x33\x32\x3\x2\x2\x2\x34\x38\x3\x2\x2\x2\x35\x38\x5\b\x5\x2"+
		"\x36\x38\x5\n\x6\x2\x37-\x3\x2\x2\x2\x37.\x3\x2\x2\x2\x37\x35\x3\x2\x2"+
		"\x2\x37\x36\x3\x2\x2\x2\x38\a\x3\x2\x2\x2\x39>\x5\x10\t\x2:?\x5\x16\f"+
		"\x2;?\x5 \x11\x2<?\a\x16\x2\x2=?\x5\x1E\x10\x2>:\x3\x2\x2\x2>;\x3\x2\x2"+
		"\x2><\x3\x2\x2\x2>=\x3\x2\x2\x2?I\x3\x2\x2\x2@\x41\x5\x10\t\x2\x41\x42"+
		"\x5\x1E\x10\x2\x42\x46\aM\x2\x2\x43G\x5\x16\f\x2\x44G\x5 \x11\x2\x45G"+
		"\a\x16\x2\x2\x46\x43\x3\x2\x2\x2\x46\x44\x3\x2\x2\x2\x46\x45\x3\x2\x2"+
		"\x2GI\x3\x2\x2\x2H\x39\x3\x2\x2\x2H@\x3\x2\x2\x2I\t\x3\x2\x2\x2JK\x5\x12"+
		"\n\x2KL\x5\x14\v\x2LM\aM\x2\x2MN\x5\x14\v\x2N\v\x3\x2\x2\x2OP\t\x2\x2"+
		"\x2P\r\x3\x2\x2\x2QR\t\x3\x2\x2R\xF\x3\x2\x2\x2ST\t\x4\x2\x2T\x11\x3\x2"+
		"\x2\x2UV\t\x5\x2\x2V\x13\x3\x2\x2\x2W`\x5\x1A\xE\x2X`\x5\x1C\xF\x2Y`\x5"+
		" \x11\x2Z`\x5\"\x12\x2[`\x5\x1E\x10\x2\\`\x5\x18\r\x2]`\a\x16\x2\x2^`"+
		"\x5\x16\f\x2_W\x3\x2\x2\x2_X\x3\x2\x2\x2_Y\x3\x2\x2\x2_Z\x3\x2\x2\x2_"+
		"[\x3\x2\x2\x2_\\\x3\x2\x2\x2_]\x3\x2\x2\x2_^\x3\x2\x2\x2`\x15\x3\x2\x2"+
		"\x2\x61\x65\a\x1D\x2\x2\x62\x66\x5\x1A\xE\x2\x63\x66\x5\x1C\xF\x2\x64"+
		"\x66\x5 \x11\x2\x65\x62\x3\x2\x2\x2\x65\x63\x3\x2\x2\x2\x65\x64\x3\x2"+
		"\x2\x2\x66g\x3\x2\x2\x2gh\a\x1E\x2\x2h\x17\x3\x2\x2\x2il\x5\x1A\xE\x2"+
		"jl\x5\x1C\xF\x2ki\x3\x2\x2\x2kj\x3\x2\x2\x2lm\x3\x2\x2\x2mn\a\x1A\x2\x2"+
		"no\x5 \x11\x2ow\x3\x2\x2\x2ps\x5\x1A\xE\x2qs\x5\x1C\xF\x2rp\x3\x2\x2\x2"+
		"rq\x3\x2\x2\x2st\x3\x2\x2\x2tu\x5\"\x12\x2uw\x3\x2\x2\x2vk\x3\x2\x2\x2"+
		"vr\x3\x2\x2\x2w\x19\x3\x2\x2\x2xy\t\x6\x2\x2y\x1B\x3\x2\x2\x2z{\t\a\x2"+
		"\x2{\x1D\x3\x2\x2\x2|}\t\b\x2\x2}\x1F\x3\x2\x2\x2~\x7F\t\t\x2\x2\x7F!"+
		"\x3\x2\x2\x2\x80\x81\a\x19\x2\x2\x81\x82\x5 \x11\x2\x82#\x3\x2\x2\x2\r"+
		"+\x33\x37>\x46H_\x65krv";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
