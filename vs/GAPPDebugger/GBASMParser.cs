//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from GBASM.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class GBASMParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, Z=8, A=9, B=10, 
		C=11, D=12, E=13, F=14, H=15, L=16, AF=17, BC=18, DE=19, HL=20, SP=21, 
		NZ=22, NC=23, RST_VALUE=24, RST_DIGITS=25, Integer=26, Hexval=27, Neg=28, 
		Plus=29, HLPLUS=30, HLMINUS=31, MEMSTART=32, MEMEND=33, LD=34, JR=35, 
		JP=36, OR=37, CP=38, RL=39, RR=40, DI=41, EI=42, LDD=43, LDI=44, ADD=45, 
		ADC=46, SBC=47, BIT=48, RES=49, SET=50, RET=51, INC=52, DEC=53, SUB=54, 
		AND=55, XOR=56, RLC=57, RRC=58, POP=59, SLA=60, SRA=61, SRL=62, NOP=63, 
		RLA=64, RRA=65, DAA=66, CPL=67, SCF=68, CCF=69, LDH=70, RST=71, CALL=72, 
		PUSH=73, SWAP=74, RLCA=75, RRCA=76, STOP=77, HALT=78, RETI=79, STRING=80, 
		SEPARATOR=81, WS=82, COMMENT=83;
	public const int
		RULE_eval = 0, RULE_exp = 1, RULE_sys = 2, RULE_op = 3, RULE_monad = 4, 
		RULE_biad = 5, RULE_triad = 6, RULE_arg = 7, RULE_memory = 8, RULE_offset = 9, 
		RULE_register = 10, RULE_flag = 11, RULE_db = 12, RULE_include = 13, RULE_section = 14, 
		RULE_literal = 15, RULE_jump = 16, RULE_label = 17, RULE_value = 18, RULE_negvalue = 19;
	public static readonly string[] ruleNames = {
		"eval", "exp", "sys", "op", "monad", "biad", "triad", "arg", "memory", 
		"offset", "register", "flag", "db", "include", "section", "literal", "jump", 
		"label", "value", "negvalue"
	};

	private static readonly string[] _LiteralNames = {
		null, "'INCLUDE'", "'SECTION'", "'HOME'", "'['", "']'", "'\"'", "':'", 
		"'Z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'H'", "'L'", "'AF'", 
		"'BC'", "'DE'", "'HL'", "'SP'", "'NZ'", "'NC'", null, null, null, null, 
		"'-'", "'+'", null, null, "'('", "')'", null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, "','"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, "Z", "A", "B", "C", "D", 
		"E", "F", "H", "L", "AF", "BC", "DE", "HL", "SP", "NZ", "NC", "RST_VALUE", 
		"RST_DIGITS", "Integer", "Hexval", "Neg", "Plus", "HLPLUS", "HLMINUS", 
		"MEMSTART", "MEMEND", "LD", "JR", "JP", "OR", "CP", "RL", "RR", "DI", 
		"EI", "LDD", "LDI", "ADD", "ADC", "SBC", "BIT", "RES", "SET", "RET", "INC", 
		"DEC", "SUB", "AND", "XOR", "RLC", "RRC", "POP", "SLA", "SRA", "SRL", 
		"NOP", "RLA", "RRA", "DAA", "CPL", "SCF", "CCF", "LDH", "RST", "CALL", 
		"PUSH", "SWAP", "RLCA", "RRCA", "STOP", "HALT", "RETI", "STRING", "SEPARATOR", 
		"WS", "COMMENT"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GBASM.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GBASMParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class EvalContext : ParserRuleContext {
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(GBASMParser.Eof, 0); }
		public EvalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eval; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterEval(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitEval(this);
		}
	}

	[RuleVersion(0)]
	public EvalContext eval() {
		EvalContext _localctx = new EvalContext(Context, State);
		EnterRule(_localctx, 0, RULE_eval);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 40; exp();
			State = 41; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpContext : ParserRuleContext {
		public SysContext sys() {
			return GetRuleContext<SysContext>(0);
		}
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public OpContext op() {
			return GetRuleContext<OpContext>(0);
		}
		public ExpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterExp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitExp(this);
		}
	}

	[RuleVersion(0)]
	public ExpContext exp() {
		ExpContext _localctx = new ExpContext(Context, State);
		EnterRule(_localctx, 2, RULE_exp);
		try {
			State = 51;
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 43; sys();
				State = 44; exp();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 46; op();
				State = 47; exp();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 49; sys();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 50; op();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SysContext : ParserRuleContext {
		public IncludeContext include() {
			return GetRuleContext<IncludeContext>(0);
		}
		public SectionContext section() {
			return GetRuleContext<SectionContext>(0);
		}
		public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public DbContext db() {
			return GetRuleContext<DbContext>(0);
		}
		public SysContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sys; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterSys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitSys(this);
		}
	}

	[RuleVersion(0)]
	public SysContext sys() {
		SysContext _localctx = new SysContext(Context, State);
		EnterRule(_localctx, 4, RULE_sys);
		try {
			State = 57;
			switch (TokenStream.La(1)) {
			case T__0:
				EnterOuterAlt(_localctx, 1);
				{
				State = 53; include();
				}
				break;
			case T__1:
				EnterOuterAlt(_localctx, 2);
				{
				State = 54; section();
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 55; label();
				}
				break;
			case T__5:
			case Integer:
			case Hexval:
				EnterOuterAlt(_localctx, 4);
				{
				State = 56; db();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpContext : ParserRuleContext {
		public MonadContext monad() {
			return GetRuleContext<MonadContext>(0);
		}
		public BiadContext biad() {
			return GetRuleContext<BiadContext>(0);
		}
		public ArgContext[] arg() {
			return GetRuleContexts<ArgContext>();
		}
		public ArgContext arg(int i) {
			return GetRuleContext<ArgContext>(i);
		}
		public TriadContext triad() {
			return GetRuleContext<TriadContext>(0);
		}
		public ITerminalNode SEPARATOR() { return GetToken(GBASMParser.SEPARATOR, 0); }
		public OpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitOp(this);
		}
	}

	[RuleVersion(0)]
	public OpContext op() {
		OpContext _localctx = new OpContext(Context, State);
		EnterRule(_localctx, 6, RULE_op);
		try {
			State = 68;
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 59; monad();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 60; biad();
				State = 61; arg();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 63; triad();
				State = 64; arg();
				State = 65; Match(SEPARATOR);
				State = 66; arg();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MonadContext : ParserRuleContext {
		public ITerminalNode NOP() { return GetToken(GBASMParser.NOP, 0); }
		public ITerminalNode RLCA() { return GetToken(GBASMParser.RLCA, 0); }
		public ITerminalNode RRCA() { return GetToken(GBASMParser.RRCA, 0); }
		public ITerminalNode STOP() { return GetToken(GBASMParser.STOP, 0); }
		public ITerminalNode RLA() { return GetToken(GBASMParser.RLA, 0); }
		public ITerminalNode RRA() { return GetToken(GBASMParser.RRA, 0); }
		public ITerminalNode DAA() { return GetToken(GBASMParser.DAA, 0); }
		public ITerminalNode CPL() { return GetToken(GBASMParser.CPL, 0); }
		public ITerminalNode SCF() { return GetToken(GBASMParser.SCF, 0); }
		public ITerminalNode CCF() { return GetToken(GBASMParser.CCF, 0); }
		public ITerminalNode HALT() { return GetToken(GBASMParser.HALT, 0); }
		public ITerminalNode RETI() { return GetToken(GBASMParser.RETI, 0); }
		public ITerminalNode DI() { return GetToken(GBASMParser.DI, 0); }
		public ITerminalNode EI() { return GetToken(GBASMParser.EI, 0); }
		public ITerminalNode RST() { return GetToken(GBASMParser.RST, 0); }
		public ITerminalNode RET() { return GetToken(GBASMParser.RET, 0); }
		public MonadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_monad; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterMonad(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitMonad(this);
		}
	}

	[RuleVersion(0)]
	public MonadContext monad() {
		MonadContext _localctx = new MonadContext(Context, State);
		EnterRule(_localctx, 8, RULE_monad);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 70;
			_la = TokenStream.La(1);
			if ( !(((((_la - 41)) & ~0x3f) == 0 && ((1L << (_la - 41)) & ((1L << (DI - 41)) | (1L << (EI - 41)) | (1L << (RET - 41)) | (1L << (NOP - 41)) | (1L << (RLA - 41)) | (1L << (RRA - 41)) | (1L << (DAA - 41)) | (1L << (CPL - 41)) | (1L << (SCF - 41)) | (1L << (CCF - 41)) | (1L << (RST - 41)) | (1L << (RLCA - 41)) | (1L << (RRCA - 41)) | (1L << (STOP - 41)) | (1L << (HALT - 41)) | (1L << (RETI - 41)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BiadContext : ParserRuleContext {
		public ITerminalNode INC() { return GetToken(GBASMParser.INC, 0); }
		public ITerminalNode DEC() { return GetToken(GBASMParser.DEC, 0); }
		public ITerminalNode SUB() { return GetToken(GBASMParser.SUB, 0); }
		public ITerminalNode AND() { return GetToken(GBASMParser.AND, 0); }
		public ITerminalNode XOR() { return GetToken(GBASMParser.XOR, 0); }
		public ITerminalNode OR() { return GetToken(GBASMParser.OR, 0); }
		public ITerminalNode CP() { return GetToken(GBASMParser.CP, 0); }
		public ITerminalNode POP() { return GetToken(GBASMParser.POP, 0); }
		public ITerminalNode PUSH() { return GetToken(GBASMParser.PUSH, 0); }
		public ITerminalNode RLC() { return GetToken(GBASMParser.RLC, 0); }
		public ITerminalNode RRC() { return GetToken(GBASMParser.RRC, 0); }
		public ITerminalNode RL() { return GetToken(GBASMParser.RL, 0); }
		public ITerminalNode RR() { return GetToken(GBASMParser.RR, 0); }
		public ITerminalNode SLA() { return GetToken(GBASMParser.SLA, 0); }
		public ITerminalNode SRA() { return GetToken(GBASMParser.SRA, 0); }
		public ITerminalNode SWAP() { return GetToken(GBASMParser.SWAP, 0); }
		public ITerminalNode SRL() { return GetToken(GBASMParser.SRL, 0); }
		public ITerminalNode JP() { return GetToken(GBASMParser.JP, 0); }
		public ITerminalNode JR() { return GetToken(GBASMParser.JR, 0); }
		public BiadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_biad; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterBiad(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitBiad(this);
		}
	}

	[RuleVersion(0)]
	public BiadContext biad() {
		BiadContext _localctx = new BiadContext(Context, State);
		EnterRule(_localctx, 10, RULE_biad);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 72;
			_la = TokenStream.La(1);
			if ( !(((((_la - 35)) & ~0x3f) == 0 && ((1L << (_la - 35)) & ((1L << (JR - 35)) | (1L << (JP - 35)) | (1L << (OR - 35)) | (1L << (CP - 35)) | (1L << (RL - 35)) | (1L << (RR - 35)) | (1L << (INC - 35)) | (1L << (DEC - 35)) | (1L << (SUB - 35)) | (1L << (AND - 35)) | (1L << (XOR - 35)) | (1L << (RLC - 35)) | (1L << (RRC - 35)) | (1L << (POP - 35)) | (1L << (SLA - 35)) | (1L << (SRA - 35)) | (1L << (SRL - 35)) | (1L << (PUSH - 35)) | (1L << (SWAP - 35)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriadContext : ParserRuleContext {
		public ITerminalNode RET() { return GetToken(GBASMParser.RET, 0); }
		public ITerminalNode JR() { return GetToken(GBASMParser.JR, 0); }
		public ITerminalNode JP() { return GetToken(GBASMParser.JP, 0); }
		public ITerminalNode CALL() { return GetToken(GBASMParser.CALL, 0); }
		public ITerminalNode LD() { return GetToken(GBASMParser.LD, 0); }
		public ITerminalNode LDD() { return GetToken(GBASMParser.LDD, 0); }
		public ITerminalNode LDI() { return GetToken(GBASMParser.LDI, 0); }
		public ITerminalNode LDH() { return GetToken(GBASMParser.LDH, 0); }
		public ITerminalNode ADD() { return GetToken(GBASMParser.ADD, 0); }
		public ITerminalNode ADC() { return GetToken(GBASMParser.ADC, 0); }
		public ITerminalNode SBC() { return GetToken(GBASMParser.SBC, 0); }
		public ITerminalNode BIT() { return GetToken(GBASMParser.BIT, 0); }
		public ITerminalNode RES() { return GetToken(GBASMParser.RES, 0); }
		public ITerminalNode SET() { return GetToken(GBASMParser.SET, 0); }
		public TriadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triad; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterTriad(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitTriad(this);
		}
	}

	[RuleVersion(0)]
	public TriadContext triad() {
		TriadContext _localctx = new TriadContext(Context, State);
		EnterRule(_localctx, 12, RULE_triad);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 74;
			_la = TokenStream.La(1);
			if ( !(((((_la - 34)) & ~0x3f) == 0 && ((1L << (_la - 34)) & ((1L << (LD - 34)) | (1L << (JR - 34)) | (1L << (JP - 34)) | (1L << (LDD - 34)) | (1L << (LDI - 34)) | (1L << (ADD - 34)) | (1L << (ADC - 34)) | (1L << (SBC - 34)) | (1L << (BIT - 34)) | (1L << (RES - 34)) | (1L << (SET - 34)) | (1L << (RET - 34)) | (1L << (LDH - 34)) | (1L << (CALL - 34)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgContext : ParserRuleContext {
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext negvalue() {
			return GetRuleContext<NegvalueContext>(0);
		}
		public FlagContext flag() {
			return GetRuleContext<FlagContext>(0);
		}
		public OffsetContext offset() {
			return GetRuleContext<OffsetContext>(0);
		}
		public JumpContext jump() {
			return GetRuleContext<JumpContext>(0);
		}
		public MemoryContext memory() {
			return GetRuleContext<MemoryContext>(0);
		}
		public ArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arg; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterArg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitArg(this);
		}
	}

	[RuleVersion(0)]
	public ArgContext arg() {
		ArgContext _localctx = new ArgContext(Context, State);
		EnterRule(_localctx, 14, RULE_arg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 83;
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				{
				State = 76; register();
				}
				break;
			case 2:
				{
				State = 77; value();
				}
				break;
			case 3:
				{
				State = 78; negvalue();
				}
				break;
			case 4:
				{
				State = 79; flag();
				}
				break;
			case 5:
				{
				State = 80; offset();
				}
				break;
			case 6:
				{
				State = 81; jump();
				}
				break;
			case 7:
				{
				State = 82; memory();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemoryContext : ParserRuleContext {
		public ITerminalNode MEMSTART() { return GetToken(GBASMParser.MEMSTART, 0); }
		public ITerminalNode MEMEND() { return GetToken(GBASMParser.MEMEND, 0); }
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public MemoryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memory; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterMemory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitMemory(this);
		}
	}

	[RuleVersion(0)]
	public MemoryContext memory() {
		MemoryContext _localctx = new MemoryContext(Context, State);
		EnterRule(_localctx, 16, RULE_memory);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 85; Match(MEMSTART);
			State = 88;
			switch (TokenStream.La(1)) {
			case A:
			case B:
			case C:
			case D:
			case E:
			case F:
			case H:
			case L:
			case AF:
			case BC:
			case DE:
			case HL:
			case SP:
			case HLPLUS:
			case HLMINUS:
				{
				State = 86; register();
				}
				break;
			case Integer:
			case Hexval:
				{
				State = 87; value();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 90; Match(MEMEND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OffsetContext : ParserRuleContext {
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public ITerminalNode Plus() { return GetToken(GBASMParser.Plus, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext negvalue() {
			return GetRuleContext<NegvalueContext>(0);
		}
		public OffsetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_offset; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterOffset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitOffset(this);
		}
	}

	[RuleVersion(0)]
	public OffsetContext offset() {
		OffsetContext _localctx = new OffsetContext(Context, State);
		EnterRule(_localctx, 18, RULE_offset);
		try {
			State = 99;
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 92; register();
				State = 93; Match(Plus);
				State = 94; value();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 96; register();
				State = 97; negvalue();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegisterContext : ParserRuleContext {
		public ITerminalNode A() { return GetToken(GBASMParser.A, 0); }
		public ITerminalNode B() { return GetToken(GBASMParser.B, 0); }
		public ITerminalNode C() { return GetToken(GBASMParser.C, 0); }
		public ITerminalNode D() { return GetToken(GBASMParser.D, 0); }
		public ITerminalNode E() { return GetToken(GBASMParser.E, 0); }
		public ITerminalNode F() { return GetToken(GBASMParser.F, 0); }
		public ITerminalNode H() { return GetToken(GBASMParser.H, 0); }
		public ITerminalNode L() { return GetToken(GBASMParser.L, 0); }
		public ITerminalNode AF() { return GetToken(GBASMParser.AF, 0); }
		public ITerminalNode BC() { return GetToken(GBASMParser.BC, 0); }
		public ITerminalNode DE() { return GetToken(GBASMParser.DE, 0); }
		public ITerminalNode HL() { return GetToken(GBASMParser.HL, 0); }
		public ITerminalNode SP() { return GetToken(GBASMParser.SP, 0); }
		public ITerminalNode HLPLUS() { return GetToken(GBASMParser.HLPLUS, 0); }
		public ITerminalNode HLMINUS() { return GetToken(GBASMParser.HLMINUS, 0); }
		public RegisterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_register; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterRegister(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitRegister(this);
		}
	}

	[RuleVersion(0)]
	public RegisterContext register() {
		RegisterContext _localctx = new RegisterContext(Context, State);
		EnterRule(_localctx, 20, RULE_register);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 101;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A) | (1L << B) | (1L << C) | (1L << D) | (1L << E) | (1L << F) | (1L << H) | (1L << L) | (1L << AF) | (1L << BC) | (1L << DE) | (1L << HL) | (1L << SP) | (1L << HLPLUS) | (1L << HLMINUS))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlagContext : ParserRuleContext {
		public ITerminalNode NZ() { return GetToken(GBASMParser.NZ, 0); }
		public ITerminalNode NC() { return GetToken(GBASMParser.NC, 0); }
		public ITerminalNode Z() { return GetToken(GBASMParser.Z, 0); }
		public ITerminalNode C() { return GetToken(GBASMParser.C, 0); }
		public FlagContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flag; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterFlag(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitFlag(this);
		}
	}

	[RuleVersion(0)]
	public FlagContext flag() {
		FlagContext _localctx = new FlagContext(Context, State);
		EnterRule(_localctx, 22, RULE_flag);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 103;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Z) | (1L << C) | (1L << NZ) | (1L << NC))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DbContext : ParserRuleContext {
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ITerminalNode SEPARATOR() { return GetToken(GBASMParser.SEPARATOR, 0); }
		public DbContext db() {
			return GetRuleContext<DbContext>(0);
		}
		public DbContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_db; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterDb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitDb(this);
		}
	}

	[RuleVersion(0)]
	public DbContext db() {
		DbContext _localctx = new DbContext(Context, State);
		EnterRule(_localctx, 24, RULE_db);
		try {
			State = 115;
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 105; literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 106; value();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 107; literal();
				State = 108; Match(SEPARATOR);
				State = 109; db();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 111; value();
				State = 112; Match(SEPARATOR);
				State = 113; db();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludeContext : ParserRuleContext {
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public IncludeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_include; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterInclude(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitInclude(this);
		}
	}

	[RuleVersion(0)]
	public IncludeContext include() {
		IncludeContext _localctx = new IncludeContext(Context, State);
		EnterRule(_localctx, 26, RULE_include);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 117; Match(T__0);
			State = 118; literal();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SectionContext : ParserRuleContext {
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ITerminalNode SEPARATOR() { return GetToken(GBASMParser.SEPARATOR, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public SectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterSection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitSection(this);
		}
	}

	[RuleVersion(0)]
	public SectionContext section() {
		SectionContext _localctx = new SectionContext(Context, State);
		EnterRule(_localctx, 28, RULE_section);
		try {
			State = 130;
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 120; Match(T__1);
				State = 121; literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 122; Match(T__1);
				State = 123; literal();
				State = 124; Match(SEPARATOR);
				State = 125; Match(T__2);
				State = 126; Match(T__3);
				State = 127; value();
				State = 128; Match(T__4);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public ITerminalNode STRING() { return GetToken(GBASMParser.STRING, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 30, RULE_literal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132; Match(T__5);
			State = 133; Match(STRING);
			State = 134; Match(T__5);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpContext : ParserRuleContext {
		public ITerminalNode STRING() { return GetToken(GBASMParser.STRING, 0); }
		public JumpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jump; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterJump(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitJump(this);
		}
	}

	[RuleVersion(0)]
	public JumpContext jump() {
		JumpContext _localctx = new JumpContext(Context, State);
		EnterRule(_localctx, 32, RULE_jump);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 136; Match(STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		public ITerminalNode STRING() { return GetToken(GBASMParser.STRING, 0); }
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(Context, State);
		EnterRule(_localctx, 34, RULE_label);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138; Match(STRING);
			State = 139; Match(T__6);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		public ITerminalNode Hexval() { return GetToken(GBASMParser.Hexval, 0); }
		public ITerminalNode Integer() { return GetToken(GBASMParser.Integer, 0); }
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitValue(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(Context, State);
		EnterRule(_localctx, 36, RULE_value);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			_la = TokenStream.La(1);
			if ( !(_la==Integer || _la==Hexval) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NegvalueContext : ParserRuleContext {
		public ITerminalNode Neg() { return GetToken(GBASMParser.Neg, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negvalue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterNegvalue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitNegvalue(this);
		}
	}

	[RuleVersion(0)]
	public NegvalueContext negvalue() {
		NegvalueContext _localctx = new NegvalueContext(Context, State);
		EnterRule(_localctx, 38, RULE_negvalue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 143; Match(Neg);
			State = 144; value();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3U\x95\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x5"+
		"\x3\x36\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4<\n\x4\x3\x5\x3\x5\x3\x5\x3"+
		"\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5G\n\x5\x3\x6\x3\x6\x3\a\x3\a\x3"+
		"\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\tV\n\t\x3\n\x3\n\x3\n\x5"+
		"\n[\n\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\x66\n\v\x3\f"+
		"\x3\f\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE"+
		"\x3\xE\x5\xEv\n\xE\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5\x10\x85\n\x10\x3\x11\x3\x11\x3"+
		"\x11\x3\x11\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x14\x3\x14\x3\x15\x3"+
		"\x15\x3\x15\x3\x15\x2\x2\x16\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A"+
		"\x1C\x1E \"$&(\x2\b\a\x2+,\x35\x35\x41GIIMQ\x5\x2%*\x36@KL\x6\x2$&-\x35"+
		"HHJJ\x4\x2\v\x17 !\x5\x2\n\n\r\r\x18\x19\x3\x2\x1C\x1D\x94\x2*\x3\x2\x2"+
		"\x2\x4\x35\x3\x2\x2\x2\x6;\x3\x2\x2\x2\b\x46\x3\x2\x2\x2\nH\x3\x2\x2\x2"+
		"\fJ\x3\x2\x2\x2\xEL\x3\x2\x2\x2\x10U\x3\x2\x2\x2\x12W\x3\x2\x2\x2\x14"+
		"\x65\x3\x2\x2\x2\x16g\x3\x2\x2\x2\x18i\x3\x2\x2\x2\x1Au\x3\x2\x2\x2\x1C"+
		"w\x3\x2\x2\x2\x1E\x84\x3\x2\x2\x2 \x86\x3\x2\x2\x2\"\x8A\x3\x2\x2\x2$"+
		"\x8C\x3\x2\x2\x2&\x8F\x3\x2\x2\x2(\x91\x3\x2\x2\x2*+\x5\x4\x3\x2+,\a\x2"+
		"\x2\x3,\x3\x3\x2\x2\x2-.\x5\x6\x4\x2./\x5\x4\x3\x2/\x36\x3\x2\x2\x2\x30"+
		"\x31\x5\b\x5\x2\x31\x32\x5\x4\x3\x2\x32\x36\x3\x2\x2\x2\x33\x36\x5\x6"+
		"\x4\x2\x34\x36\x5\b\x5\x2\x35-\x3\x2\x2\x2\x35\x30\x3\x2\x2\x2\x35\x33"+
		"\x3\x2\x2\x2\x35\x34\x3\x2\x2\x2\x36\x5\x3\x2\x2\x2\x37<\x5\x1C\xF\x2"+
		"\x38<\x5\x1E\x10\x2\x39<\x5$\x13\x2:<\x5\x1A\xE\x2;\x37\x3\x2\x2\x2;\x38"+
		"\x3\x2\x2\x2;\x39\x3\x2\x2\x2;:\x3\x2\x2\x2<\a\x3\x2\x2\x2=G\x5\n\x6\x2"+
		">?\x5\f\a\x2?@\x5\x10\t\x2@G\x3\x2\x2\x2\x41\x42\x5\xE\b\x2\x42\x43\x5"+
		"\x10\t\x2\x43\x44\aS\x2\x2\x44\x45\x5\x10\t\x2\x45G\x3\x2\x2\x2\x46=\x3"+
		"\x2\x2\x2\x46>\x3\x2\x2\x2\x46\x41\x3\x2\x2\x2G\t\x3\x2\x2\x2HI\t\x2\x2"+
		"\x2I\v\x3\x2\x2\x2JK\t\x3\x2\x2K\r\x3\x2\x2\x2LM\t\x4\x2\x2M\xF\x3\x2"+
		"\x2\x2NV\x5\x16\f\x2OV\x5&\x14\x2PV\x5(\x15\x2QV\x5\x18\r\x2RV\x5\x14"+
		"\v\x2SV\x5\"\x12\x2TV\x5\x12\n\x2UN\x3\x2\x2\x2UO\x3\x2\x2\x2UP\x3\x2"+
		"\x2\x2UQ\x3\x2\x2\x2UR\x3\x2\x2\x2US\x3\x2\x2\x2UT\x3\x2\x2\x2V\x11\x3"+
		"\x2\x2\x2WZ\a\"\x2\x2X[\x5\x16\f\x2Y[\x5&\x14\x2ZX\x3\x2\x2\x2ZY\x3\x2"+
		"\x2\x2[\\\x3\x2\x2\x2\\]\a#\x2\x2]\x13\x3\x2\x2\x2^_\x5\x16\f\x2_`\a\x1F"+
		"\x2\x2`\x61\x5&\x14\x2\x61\x66\x3\x2\x2\x2\x62\x63\x5\x16\f\x2\x63\x64"+
		"\x5(\x15\x2\x64\x66\x3\x2\x2\x2\x65^\x3\x2\x2\x2\x65\x62\x3\x2\x2\x2\x66"+
		"\x15\x3\x2\x2\x2gh\t\x5\x2\x2h\x17\x3\x2\x2\x2ij\t\x6\x2\x2j\x19\x3\x2"+
		"\x2\x2kv\x5 \x11\x2lv\x5&\x14\x2mn\x5 \x11\x2no\aS\x2\x2op\x5\x1A\xE\x2"+
		"pv\x3\x2\x2\x2qr\x5&\x14\x2rs\aS\x2\x2st\x5\x1A\xE\x2tv\x3\x2\x2\x2uk"+
		"\x3\x2\x2\x2ul\x3\x2\x2\x2um\x3\x2\x2\x2uq\x3\x2\x2\x2v\x1B\x3\x2\x2\x2"+
		"wx\a\x3\x2\x2xy\x5 \x11\x2y\x1D\x3\x2\x2\x2z{\a\x4\x2\x2{\x85\x5 \x11"+
		"\x2|}\a\x4\x2\x2}~\x5 \x11\x2~\x7F\aS\x2\x2\x7F\x80\a\x5\x2\x2\x80\x81"+
		"\a\x6\x2\x2\x81\x82\x5&\x14\x2\x82\x83\a\a\x2\x2\x83\x85\x3\x2\x2\x2\x84"+
		"z\x3\x2\x2\x2\x84|\x3\x2\x2\x2\x85\x1F\x3\x2\x2\x2\x86\x87\a\b\x2\x2\x87"+
		"\x88\aR\x2\x2\x88\x89\a\b\x2\x2\x89!\x3\x2\x2\x2\x8A\x8B\aR\x2\x2\x8B"+
		"#\x3\x2\x2\x2\x8C\x8D\aR\x2\x2\x8D\x8E\a\t\x2\x2\x8E%\x3\x2\x2\x2\x8F"+
		"\x90\t\a\x2\x2\x90\'\x3\x2\x2\x2\x91\x92\a\x1E\x2\x2\x92\x93\x5&\x14\x2"+
		"\x93)\x3\x2\x2\x2\n\x35;\x46UZ\x65u\x84";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
