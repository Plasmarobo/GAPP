//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from GBASM.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class GBASMParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, Z=4, A=5, B=6, C=7, D=8, E=9, F=10, H=11, L=12, 
		AF=13, BC=14, DE=15, HL=16, SP=17, NZ=18, NC=19, Neg=20, Plus=21, Number=22, 
		HLPLUS=23, HLMINUS=24, MEMSTART=25, MEMEND=26, LD=27, JR=28, JP=29, OR=30, 
		CP=31, RL=32, RR=33, DI=34, EI=35, DB=36, LDD=37, LDI=38, ADD=39, ADC=40, 
		SBC=41, BIT=42, RES=43, SET=44, RET=45, INC=46, DEC=47, SUB=48, AND=49, 
		XOR=50, RLC=51, RRC=52, POP=53, SLA=54, SRA=55, SRL=56, NOP=57, RLA=58, 
		RRA=59, DAA=60, CPL=61, SCF=62, CCF=63, LDH=64, RST=65, CALL=66, PUSH=67, 
		SWAP=68, RLCA=69, RRCA=70, STOP=71, HALT=72, RETI=73, REPT=74, ENDR=75, 
		HOME=76, SECTION=77, INCLUDE=78, STRINGLITERAL=79, LIMSTRING=80, SEPARATOR=81, 
		WS=82, COMMENT=83;
	public const int
		RULE_eval = 0, RULE_exp = 1, RULE_op = 2, RULE_sys = 3, RULE_triad = 4, 
		RULE_biad = 5, RULE_monad = 6, RULE_arg = 7, RULE_memory = 8, RULE_offset = 9, 
		RULE_register = 10, RULE_flag = 11, RULE_data = 12, RULE_db = 13, RULE_include = 14, 
		RULE_section = 15, RULE_repblock = 16, RULE_string_data = 17, RULE_jump = 18, 
		RULE_label = 19, RULE_value = 20, RULE_negvalue = 21;
	public static readonly string[] ruleNames = {
		"eval", "exp", "op", "sys", "triad", "biad", "monad", "arg", "memory", 
		"offset", "register", "flag", "data", "db", "include", "section", "repblock", 
		"string_data", "jump", "label", "value", "negvalue"
	};

	private static readonly string[] _LiteralNames = {
		null, "'['", "']'", "':'", "'Z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", 
		"'H'", "'L'", "'AF'", "'BC'", "'DE'", "'HL'", "'SP'", "'NZ'", "'NC'", 
		"'-'", "'+'", null, null, null, "'('", "')'", null, null, null, null, 
		null, null, null, null, null, "'DB'", null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, "'HOME'", "'SECTION'", 
		"'INCLUDE'", null, null, "','"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, "Z", "A", "B", "C", "D", "E", "F", "H", "L", "AF", 
		"BC", "DE", "HL", "SP", "NZ", "NC", "Neg", "Plus", "Number", "HLPLUS", 
		"HLMINUS", "MEMSTART", "MEMEND", "LD", "JR", "JP", "OR", "CP", "RL", "RR", 
		"DI", "EI", "DB", "LDD", "LDI", "ADD", "ADC", "SBC", "BIT", "RES", "SET", 
		"RET", "INC", "DEC", "SUB", "AND", "XOR", "RLC", "RRC", "POP", "SLA", 
		"SRA", "SRL", "NOP", "RLA", "RRA", "DAA", "CPL", "SCF", "CCF", "LDH", 
		"RST", "CALL", "PUSH", "SWAP", "RLCA", "RRCA", "STOP", "HALT", "RETI", 
		"REPT", "ENDR", "HOME", "SECTION", "INCLUDE", "STRINGLITERAL", "LIMSTRING", 
		"SEPARATOR", "WS", "COMMENT"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GBASM.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GBASMParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class EvalContext : ParserRuleContext {
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(GBASMParser.Eof, 0); }
		public EvalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eval; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterEval(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitEval(this);
		}
	}

	[RuleVersion(0)]
	public EvalContext eval() {
		EvalContext _localctx = new EvalContext(Context, State);
		EnterRule(_localctx, 0, RULE_eval);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 44; exp(0);
			State = 45; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpContext : ParserRuleContext {
		public OpContext op() {
			return GetRuleContext<OpContext>(0);
		}
		public SysContext sys() {
			return GetRuleContext<SysContext>(0);
		}
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ExpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterExp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitExp(this);
		}
	}

	[RuleVersion(0)]
	public ExpContext exp() {
		return exp(0);
	}

	private ExpContext exp(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpContext _localctx = new ExpContext(Context, _parentState);
		ExpContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_exp, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 50;
			switch (TokenStream.La(1)) {
			case LD:
			case JR:
			case JP:
			case OR:
			case CP:
			case RL:
			case RR:
			case DI:
			case EI:
			case DB:
			case LDD:
			case LDI:
			case ADD:
			case ADC:
			case SBC:
			case BIT:
			case RES:
			case SET:
			case RET:
			case INC:
			case DEC:
			case SUB:
			case AND:
			case XOR:
			case RLC:
			case RRC:
			case POP:
			case SLA:
			case SRA:
			case SRL:
			case NOP:
			case RLA:
			case RRA:
			case DAA:
			case CPL:
			case SCF:
			case CCF:
			case LDH:
			case RST:
			case CALL:
			case PUSH:
			case SWAP:
			case RLCA:
			case RRCA:
			case STOP:
			case HALT:
			case RETI:
				{
				State = 48; op();
				}
				break;
			case REPT:
			case SECTION:
			case INCLUDE:
			case LIMSTRING:
				{
				State = 49; sys();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 58;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 56;
					switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
					case 1:
						{
						_localctx = new ExpContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 52;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 53; op();
						}
						break;
					case 2:
						{
						_localctx = new ExpContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 54;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 55; sys();
						}
						break;
					}
					} 
				}
				State = 60;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class OpContext : ParserRuleContext {
		public MonadContext monad() {
			return GetRuleContext<MonadContext>(0);
		}
		public DataContext data() {
			return GetRuleContext<DataContext>(0);
		}
		public BiadContext biad() {
			return GetRuleContext<BiadContext>(0);
		}
		public ArgContext[] arg() {
			return GetRuleContexts<ArgContext>();
		}
		public ArgContext arg(int i) {
			return GetRuleContext<ArgContext>(i);
		}
		public TriadContext triad() {
			return GetRuleContext<TriadContext>(0);
		}
		public ITerminalNode SEPARATOR() { return GetToken(GBASMParser.SEPARATOR, 0); }
		public OpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitOp(this);
		}
	}

	[RuleVersion(0)]
	public OpContext op() {
		OpContext _localctx = new OpContext(Context, State);
		EnterRule(_localctx, 4, RULE_op);
		try {
			State = 71;
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 61; monad();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 62; data();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 63; biad();
				State = 64; arg();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 66; triad();
				State = 67; arg();
				State = 68; Match(SEPARATOR);
				State = 69; arg();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SysContext : ParserRuleContext {
		public IncludeContext include() {
			return GetRuleContext<IncludeContext>(0);
		}
		public SectionContext section() {
			return GetRuleContext<SectionContext>(0);
		}
		public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public RepblockContext repblock() {
			return GetRuleContext<RepblockContext>(0);
		}
		public SysContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sys; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterSys(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitSys(this);
		}
	}

	[RuleVersion(0)]
	public SysContext sys() {
		SysContext _localctx = new SysContext(Context, State);
		EnterRule(_localctx, 6, RULE_sys);
		try {
			State = 77;
			switch (TokenStream.La(1)) {
			case INCLUDE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 73; include();
				}
				break;
			case SECTION:
				EnterOuterAlt(_localctx, 2);
				{
				State = 74; section();
				}
				break;
			case LIMSTRING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 75; label();
				}
				break;
			case REPT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 76; repblock();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriadContext : ParserRuleContext {
		public ITerminalNode JR() { return GetToken(GBASMParser.JR, 0); }
		public ITerminalNode JP() { return GetToken(GBASMParser.JP, 0); }
		public ITerminalNode CALL() { return GetToken(GBASMParser.CALL, 0); }
		public ITerminalNode LD() { return GetToken(GBASMParser.LD, 0); }
		public ITerminalNode LDD() { return GetToken(GBASMParser.LDD, 0); }
		public ITerminalNode LDI() { return GetToken(GBASMParser.LDI, 0); }
		public ITerminalNode LDH() { return GetToken(GBASMParser.LDH, 0); }
		public ITerminalNode ADD() { return GetToken(GBASMParser.ADD, 0); }
		public ITerminalNode ADC() { return GetToken(GBASMParser.ADC, 0); }
		public ITerminalNode SBC() { return GetToken(GBASMParser.SBC, 0); }
		public ITerminalNode BIT() { return GetToken(GBASMParser.BIT, 0); }
		public ITerminalNode RES() { return GetToken(GBASMParser.RES, 0); }
		public ITerminalNode SET() { return GetToken(GBASMParser.SET, 0); }
		public TriadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triad; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterTriad(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitTriad(this);
		}
	}

	[RuleVersion(0)]
	public TriadContext triad() {
		TriadContext _localctx = new TriadContext(Context, State);
		EnterRule(_localctx, 8, RULE_triad);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 79;
			_la = TokenStream.La(1);
			if ( !(((((_la - 27)) & ~0x3f) == 0 && ((1L << (_la - 27)) & ((1L << (LD - 27)) | (1L << (JR - 27)) | (1L << (JP - 27)) | (1L << (LDD - 27)) | (1L << (LDI - 27)) | (1L << (ADD - 27)) | (1L << (ADC - 27)) | (1L << (SBC - 27)) | (1L << (BIT - 27)) | (1L << (RES - 27)) | (1L << (SET - 27)) | (1L << (LDH - 27)) | (1L << (CALL - 27)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BiadContext : ParserRuleContext {
		public ITerminalNode INC() { return GetToken(GBASMParser.INC, 0); }
		public ITerminalNode DEC() { return GetToken(GBASMParser.DEC, 0); }
		public ITerminalNode SUB() { return GetToken(GBASMParser.SUB, 0); }
		public ITerminalNode AND() { return GetToken(GBASMParser.AND, 0); }
		public ITerminalNode XOR() { return GetToken(GBASMParser.XOR, 0); }
		public ITerminalNode OR() { return GetToken(GBASMParser.OR, 0); }
		public ITerminalNode CP() { return GetToken(GBASMParser.CP, 0); }
		public ITerminalNode POP() { return GetToken(GBASMParser.POP, 0); }
		public ITerminalNode PUSH() { return GetToken(GBASMParser.PUSH, 0); }
		public ITerminalNode RLC() { return GetToken(GBASMParser.RLC, 0); }
		public ITerminalNode RRC() { return GetToken(GBASMParser.RRC, 0); }
		public ITerminalNode RL() { return GetToken(GBASMParser.RL, 0); }
		public ITerminalNode RR() { return GetToken(GBASMParser.RR, 0); }
		public ITerminalNode SLA() { return GetToken(GBASMParser.SLA, 0); }
		public ITerminalNode SRA() { return GetToken(GBASMParser.SRA, 0); }
		public ITerminalNode SWAP() { return GetToken(GBASMParser.SWAP, 0); }
		public ITerminalNode SRL() { return GetToken(GBASMParser.SRL, 0); }
		public ITerminalNode JP() { return GetToken(GBASMParser.JP, 0); }
		public ITerminalNode JR() { return GetToken(GBASMParser.JR, 0); }
		public ITerminalNode STOP() { return GetToken(GBASMParser.STOP, 0); }
		public ITerminalNode RST() { return GetToken(GBASMParser.RST, 0); }
		public ITerminalNode RET() { return GetToken(GBASMParser.RET, 0); }
		public BiadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_biad; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterBiad(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitBiad(this);
		}
	}

	[RuleVersion(0)]
	public BiadContext biad() {
		BiadContext _localctx = new BiadContext(Context, State);
		EnterRule(_localctx, 10, RULE_biad);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81;
			_la = TokenStream.La(1);
			if ( !(((((_la - 28)) & ~0x3f) == 0 && ((1L << (_la - 28)) & ((1L << (JR - 28)) | (1L << (JP - 28)) | (1L << (OR - 28)) | (1L << (CP - 28)) | (1L << (RL - 28)) | (1L << (RR - 28)) | (1L << (RET - 28)) | (1L << (INC - 28)) | (1L << (DEC - 28)) | (1L << (SUB - 28)) | (1L << (AND - 28)) | (1L << (XOR - 28)) | (1L << (RLC - 28)) | (1L << (RRC - 28)) | (1L << (POP - 28)) | (1L << (SLA - 28)) | (1L << (SRA - 28)) | (1L << (SRL - 28)) | (1L << (RST - 28)) | (1L << (PUSH - 28)) | (1L << (SWAP - 28)) | (1L << (STOP - 28)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MonadContext : ParserRuleContext {
		public ITerminalNode NOP() { return GetToken(GBASMParser.NOP, 0); }
		public ITerminalNode RLCA() { return GetToken(GBASMParser.RLCA, 0); }
		public ITerminalNode RRCA() { return GetToken(GBASMParser.RRCA, 0); }
		public ITerminalNode[] STOP() { return GetTokens(GBASMParser.STOP); }
		public ITerminalNode STOP(int i) {
			return GetToken(GBASMParser.STOP, i);
		}
		public ITerminalNode RLA() { return GetToken(GBASMParser.RLA, 0); }
		public ITerminalNode RRA() { return GetToken(GBASMParser.RRA, 0); }
		public ITerminalNode DAA() { return GetToken(GBASMParser.DAA, 0); }
		public ITerminalNode CPL() { return GetToken(GBASMParser.CPL, 0); }
		public ITerminalNode SCF() { return GetToken(GBASMParser.SCF, 0); }
		public ITerminalNode CCF() { return GetToken(GBASMParser.CCF, 0); }
		public ITerminalNode HALT() { return GetToken(GBASMParser.HALT, 0); }
		public ITerminalNode RETI() { return GetToken(GBASMParser.RETI, 0); }
		public ITerminalNode DI() { return GetToken(GBASMParser.DI, 0); }
		public ITerminalNode EI() { return GetToken(GBASMParser.EI, 0); }
		public ITerminalNode RET() { return GetToken(GBASMParser.RET, 0); }
		public MonadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_monad; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterMonad(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitMonad(this);
		}
	}

	[RuleVersion(0)]
	public MonadContext monad() {
		MonadContext _localctx = new MonadContext(Context, State);
		EnterRule(_localctx, 12, RULE_monad);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 83;
			_la = TokenStream.La(1);
			if ( !(((((_la - 34)) & ~0x3f) == 0 && ((1L << (_la - 34)) & ((1L << (DI - 34)) | (1L << (EI - 34)) | (1L << (RET - 34)) | (1L << (NOP - 34)) | (1L << (RLA - 34)) | (1L << (RRA - 34)) | (1L << (DAA - 34)) | (1L << (CPL - 34)) | (1L << (SCF - 34)) | (1L << (CCF - 34)) | (1L << (RLCA - 34)) | (1L << (RRCA - 34)) | (1L << (STOP - 34)) | (1L << (HALT - 34)) | (1L << (RETI - 34)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgContext : ParserRuleContext {
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext negvalue() {
			return GetRuleContext<NegvalueContext>(0);
		}
		public FlagContext flag() {
			return GetRuleContext<FlagContext>(0);
		}
		public OffsetContext offset() {
			return GetRuleContext<OffsetContext>(0);
		}
		public JumpContext jump() {
			return GetRuleContext<JumpContext>(0);
		}
		public MemoryContext memory() {
			return GetRuleContext<MemoryContext>(0);
		}
		public ArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arg; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterArg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitArg(this);
		}
	}

	[RuleVersion(0)]
	public ArgContext arg() {
		ArgContext _localctx = new ArgContext(Context, State);
		EnterRule(_localctx, 14, RULE_arg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92;
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				{
				State = 85; register();
				}
				break;
			case 2:
				{
				State = 86; value();
				}
				break;
			case 3:
				{
				State = 87; negvalue();
				}
				break;
			case 4:
				{
				State = 88; flag();
				}
				break;
			case 5:
				{
				State = 89; offset();
				}
				break;
			case 6:
				{
				State = 90; jump();
				}
				break;
			case 7:
				{
				State = 91; memory();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemoryContext : ParserRuleContext {
		public ITerminalNode MEMSTART() { return GetToken(GBASMParser.MEMSTART, 0); }
		public ITerminalNode MEMEND() { return GetToken(GBASMParser.MEMEND, 0); }
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public JumpContext jump() {
			return GetRuleContext<JumpContext>(0);
		}
		public MemoryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memory; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterMemory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitMemory(this);
		}
	}

	[RuleVersion(0)]
	public MemoryContext memory() {
		MemoryContext _localctx = new MemoryContext(Context, State);
		EnterRule(_localctx, 16, RULE_memory);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 94; Match(MEMSTART);
			State = 98;
			switch (TokenStream.La(1)) {
			case A:
			case B:
			case C:
			case D:
			case E:
			case F:
			case H:
			case L:
			case AF:
			case BC:
			case DE:
			case HL:
			case SP:
			case HLPLUS:
			case HLMINUS:
				{
				State = 95; register();
				}
				break;
			case Number:
				{
				State = 96; value();
				}
				break;
			case LIMSTRING:
				{
				State = 97; jump();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 100; Match(MEMEND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OffsetContext : ParserRuleContext {
		public RegisterContext register() {
			return GetRuleContext<RegisterContext>(0);
		}
		public ITerminalNode Plus() { return GetToken(GBASMParser.Plus, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public NegvalueContext negvalue() {
			return GetRuleContext<NegvalueContext>(0);
		}
		public OffsetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_offset; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterOffset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitOffset(this);
		}
	}

	[RuleVersion(0)]
	public OffsetContext offset() {
		OffsetContext _localctx = new OffsetContext(Context, State);
		EnterRule(_localctx, 18, RULE_offset);
		try {
			State = 109;
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 102; register();
				State = 103; Match(Plus);
				State = 104; value();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 106; register();
				State = 107; negvalue();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegisterContext : ParserRuleContext {
		public ITerminalNode A() { return GetToken(GBASMParser.A, 0); }
		public ITerminalNode B() { return GetToken(GBASMParser.B, 0); }
		public ITerminalNode C() { return GetToken(GBASMParser.C, 0); }
		public ITerminalNode D() { return GetToken(GBASMParser.D, 0); }
		public ITerminalNode E() { return GetToken(GBASMParser.E, 0); }
		public ITerminalNode F() { return GetToken(GBASMParser.F, 0); }
		public ITerminalNode H() { return GetToken(GBASMParser.H, 0); }
		public ITerminalNode L() { return GetToken(GBASMParser.L, 0); }
		public ITerminalNode AF() { return GetToken(GBASMParser.AF, 0); }
		public ITerminalNode BC() { return GetToken(GBASMParser.BC, 0); }
		public ITerminalNode DE() { return GetToken(GBASMParser.DE, 0); }
		public ITerminalNode HL() { return GetToken(GBASMParser.HL, 0); }
		public ITerminalNode SP() { return GetToken(GBASMParser.SP, 0); }
		public ITerminalNode HLPLUS() { return GetToken(GBASMParser.HLPLUS, 0); }
		public ITerminalNode HLMINUS() { return GetToken(GBASMParser.HLMINUS, 0); }
		public RegisterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_register; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterRegister(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitRegister(this);
		}
	}

	[RuleVersion(0)]
	public RegisterContext register() {
		RegisterContext _localctx = new RegisterContext(Context, State);
		EnterRule(_localctx, 20, RULE_register);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 111;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A) | (1L << B) | (1L << C) | (1L << D) | (1L << E) | (1L << F) | (1L << H) | (1L << L) | (1L << AF) | (1L << BC) | (1L << DE) | (1L << HL) | (1L << SP) | (1L << HLPLUS) | (1L << HLMINUS))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlagContext : ParserRuleContext {
		public ITerminalNode NZ() { return GetToken(GBASMParser.NZ, 0); }
		public ITerminalNode NC() { return GetToken(GBASMParser.NC, 0); }
		public ITerminalNode Z() { return GetToken(GBASMParser.Z, 0); }
		public ITerminalNode C() { return GetToken(GBASMParser.C, 0); }
		public FlagContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flag; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterFlag(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitFlag(this);
		}
	}

	[RuleVersion(0)]
	public FlagContext flag() {
		FlagContext _localctx = new FlagContext(Context, State);
		EnterRule(_localctx, 22, RULE_flag);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 113;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Z) | (1L << C) | (1L << NZ) | (1L << NC))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataContext : ParserRuleContext {
		public ITerminalNode DB() { return GetToken(GBASMParser.DB, 0); }
		public DbContext db() {
			return GetRuleContext<DbContext>(0);
		}
		public DataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterData(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitData(this);
		}
	}

	[RuleVersion(0)]
	public DataContext data() {
		DataContext _localctx = new DataContext(Context, State);
		EnterRule(_localctx, 24, RULE_data);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 115; Match(DB);
			State = 116; db();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DbContext : ParserRuleContext {
		public String_dataContext string_data() {
			return GetRuleContext<String_dataContext>(0);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ITerminalNode SEPARATOR() { return GetToken(GBASMParser.SEPARATOR, 0); }
		public DbContext db() {
			return GetRuleContext<DbContext>(0);
		}
		public DbContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_db; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterDb(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitDb(this);
		}
	}

	[RuleVersion(0)]
	public DbContext db() {
		DbContext _localctx = new DbContext(Context, State);
		EnterRule(_localctx, 26, RULE_db);
		try {
			State = 128;
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 118; string_data();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 119; value();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 120; string_data();
				State = 121; Match(SEPARATOR);
				State = 122; db();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 124; value();
				State = 125; Match(SEPARATOR);
				State = 126; db();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludeContext : ParserRuleContext {
		public ITerminalNode INCLUDE() { return GetToken(GBASMParser.INCLUDE, 0); }
		public String_dataContext string_data() {
			return GetRuleContext<String_dataContext>(0);
		}
		public IncludeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_include; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterInclude(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitInclude(this);
		}
	}

	[RuleVersion(0)]
	public IncludeContext include() {
		IncludeContext _localctx = new IncludeContext(Context, State);
		EnterRule(_localctx, 28, RULE_include);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 130; Match(INCLUDE);
			State = 131; string_data();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SectionContext : ParserRuleContext {
		public ITerminalNode SECTION() { return GetToken(GBASMParser.SECTION, 0); }
		public String_dataContext string_data() {
			return GetRuleContext<String_dataContext>(0);
		}
		public ITerminalNode SEPARATOR() { return GetToken(GBASMParser.SEPARATOR, 0); }
		public ITerminalNode HOME() { return GetToken(GBASMParser.HOME, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public SectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterSection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitSection(this);
		}
	}

	[RuleVersion(0)]
	public SectionContext section() {
		SectionContext _localctx = new SectionContext(Context, State);
		EnterRule(_localctx, 30, RULE_section);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 133; Match(SECTION);
			State = 134; string_data();
			State = 135; Match(SEPARATOR);
			State = 136; Match(HOME);
			State = 137; Match(T__0);
			State = 138; value();
			State = 139; Match(T__1);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RepblockContext : ParserRuleContext {
		public ITerminalNode REPT() { return GetToken(GBASMParser.REPT, 0); }
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ITerminalNode ENDR() { return GetToken(GBASMParser.ENDR, 0); }
		public RepblockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_repblock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterRepblock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitRepblock(this);
		}
	}

	[RuleVersion(0)]
	public RepblockContext repblock() {
		RepblockContext _localctx = new RepblockContext(Context, State);
		EnterRule(_localctx, 32, RULE_repblock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 141; Match(REPT);
			State = 142; value();
			State = 143; exp(0);
			State = 144; Match(ENDR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_dataContext : ParserRuleContext {
		public ITerminalNode STRINGLITERAL() { return GetToken(GBASMParser.STRINGLITERAL, 0); }
		public String_dataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_data; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterString_data(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitString_data(this);
		}
	}

	[RuleVersion(0)]
	public String_dataContext string_data() {
		String_dataContext _localctx = new String_dataContext(Context, State);
		EnterRule(_localctx, 34, RULE_string_data);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 146; Match(STRINGLITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpContext : ParserRuleContext {
		public ITerminalNode LIMSTRING() { return GetToken(GBASMParser.LIMSTRING, 0); }
		public JumpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jump; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterJump(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitJump(this);
		}
	}

	[RuleVersion(0)]
	public JumpContext jump() {
		JumpContext _localctx = new JumpContext(Context, State);
		EnterRule(_localctx, 36, RULE_jump);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 148; Match(LIMSTRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		public ITerminalNode LIMSTRING() { return GetToken(GBASMParser.LIMSTRING, 0); }
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(Context, State);
		EnterRule(_localctx, 38, RULE_label);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 150; Match(LIMSTRING);
			State = 151; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		public ITerminalNode Number() { return GetToken(GBASMParser.Number, 0); }
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitValue(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(Context, State);
		EnterRule(_localctx, 40, RULE_value);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153; Match(Number);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NegvalueContext : ParserRuleContext {
		public ITerminalNode Neg() { return GetToken(GBASMParser.Neg, 0); }
		public ITerminalNode Number() { return GetToken(GBASMParser.Number, 0); }
		public NegvalueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negvalue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.EnterNegvalue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGBASMListener typedListener = listener as IGBASMListener;
			if (typedListener != null) typedListener.ExitNegvalue(this);
		}
	}

	[RuleVersion(0)]
	public NegvalueContext negvalue() {
		NegvalueContext _localctx = new NegvalueContext(Context, State);
		EnterRule(_localctx, 42, RULE_negvalue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 155; Match(Neg);
			State = 156; Match(Number);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return exp_sempred((ExpContext)_localctx, predIndex);
		}
		return true;
	}
	private bool exp_sempred(ExpContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 4);
		case 1: return Precpred(Context, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3U\xA1\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x5\x3\x35"+
		"\n\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3;\n\x3\f\x3\xE\x3>\v\x3\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4J\n\x4\x3\x5\x3"+
		"\x5\x3\x5\x3\x5\x5\x5P\n\x5\x3\x6\x3\x6\x3\a\x3\a\x3\b\x3\b\x3\t\x3\t"+
		"\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t_\n\t\x3\n\x3\n\x3\n\x3\n\x5\n\x65\n\n\x3"+
		"\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x5\vp\n\v\x3\f\x3\f\x3\r\x3"+
		"\r\x3\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3"+
		"\xF\x3\xF\x5\xF\x83\n\xF\x3\x10\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x3"+
		"\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3"+
		"\x13\x3\x13\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x17\x3"+
		"\x17\x3\x17\x3\x17\x2\x3\x4\x18\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18"+
		"\x1A\x1C\x1E \"$&(*,\x2\a\x6\x2\x1D\x1F\'.\x42\x42\x44\x44\a\x2\x1E#/"+
		":\x43\x43\x45\x46II\x6\x2$%//;\x41GK\x4\x2\a\x13\x19\x1A\x5\x2\x6\x6\t"+
		"\t\x14\x15\x9F\x2.\x3\x2\x2\x2\x4\x34\x3\x2\x2\x2\x6I\x3\x2\x2\x2\bO\x3"+
		"\x2\x2\x2\nQ\x3\x2\x2\x2\fS\x3\x2\x2\x2\xEU\x3\x2\x2\x2\x10^\x3\x2\x2"+
		"\x2\x12`\x3\x2\x2\x2\x14o\x3\x2\x2\x2\x16q\x3\x2\x2\x2\x18s\x3\x2\x2\x2"+
		"\x1Au\x3\x2\x2\x2\x1C\x82\x3\x2\x2\x2\x1E\x84\x3\x2\x2\x2 \x87\x3\x2\x2"+
		"\x2\"\x8F\x3\x2\x2\x2$\x94\x3\x2\x2\x2&\x96\x3\x2\x2\x2(\x98\x3\x2\x2"+
		"\x2*\x9B\x3\x2\x2\x2,\x9D\x3\x2\x2\x2./\x5\x4\x3\x2/\x30\a\x2\x2\x3\x30"+
		"\x3\x3\x2\x2\x2\x31\x32\b\x3\x1\x2\x32\x35\x5\x6\x4\x2\x33\x35\x5\b\x5"+
		"\x2\x34\x31\x3\x2\x2\x2\x34\x33\x3\x2\x2\x2\x35<\x3\x2\x2\x2\x36\x37\f"+
		"\x6\x2\x2\x37;\x5\x6\x4\x2\x38\x39\f\x5\x2\x2\x39;\x5\b\x5\x2:\x36\x3"+
		"\x2\x2\x2:\x38\x3\x2\x2\x2;>\x3\x2\x2\x2<:\x3\x2\x2\x2<=\x3\x2\x2\x2="+
		"\x5\x3\x2\x2\x2><\x3\x2\x2\x2?J\x5\xE\b\x2@J\x5\x1A\xE\x2\x41\x42\x5\f"+
		"\a\x2\x42\x43\x5\x10\t\x2\x43J\x3\x2\x2\x2\x44\x45\x5\n\x6\x2\x45\x46"+
		"\x5\x10\t\x2\x46G\aS\x2\x2GH\x5\x10\t\x2HJ\x3\x2\x2\x2I?\x3\x2\x2\x2I"+
		"@\x3\x2\x2\x2I\x41\x3\x2\x2\x2I\x44\x3\x2\x2\x2J\a\x3\x2\x2\x2KP\x5\x1E"+
		"\x10\x2LP\x5 \x11\x2MP\x5(\x15\x2NP\x5\"\x12\x2OK\x3\x2\x2\x2OL\x3\x2"+
		"\x2\x2OM\x3\x2\x2\x2ON\x3\x2\x2\x2P\t\x3\x2\x2\x2QR\t\x2\x2\x2R\v\x3\x2"+
		"\x2\x2ST\t\x3\x2\x2T\r\x3\x2\x2\x2UV\t\x4\x2\x2V\xF\x3\x2\x2\x2W_\x5\x16"+
		"\f\x2X_\x5*\x16\x2Y_\x5,\x17\x2Z_\x5\x18\r\x2[_\x5\x14\v\x2\\_\x5&\x14"+
		"\x2]_\x5\x12\n\x2^W\x3\x2\x2\x2^X\x3\x2\x2\x2^Y\x3\x2\x2\x2^Z\x3\x2\x2"+
		"\x2^[\x3\x2\x2\x2^\\\x3\x2\x2\x2^]\x3\x2\x2\x2_\x11\x3\x2\x2\x2`\x64\a"+
		"\x1B\x2\x2\x61\x65\x5\x16\f\x2\x62\x65\x5*\x16\x2\x63\x65\x5&\x14\x2\x64"+
		"\x61\x3\x2\x2\x2\x64\x62\x3\x2\x2\x2\x64\x63\x3\x2\x2\x2\x65\x66\x3\x2"+
		"\x2\x2\x66g\a\x1C\x2\x2g\x13\x3\x2\x2\x2hi\x5\x16\f\x2ij\a\x17\x2\x2j"+
		"k\x5*\x16\x2kp\x3\x2\x2\x2lm\x5\x16\f\x2mn\x5,\x17\x2np\x3\x2\x2\x2oh"+
		"\x3\x2\x2\x2ol\x3\x2\x2\x2p\x15\x3\x2\x2\x2qr\t\x5\x2\x2r\x17\x3\x2\x2"+
		"\x2st\t\x6\x2\x2t\x19\x3\x2\x2\x2uv\a&\x2\x2vw\x5\x1C\xF\x2w\x1B\x3\x2"+
		"\x2\x2x\x83\x5$\x13\x2y\x83\x5*\x16\x2z{\x5$\x13\x2{|\aS\x2\x2|}\x5\x1C"+
		"\xF\x2}\x83\x3\x2\x2\x2~\x7F\x5*\x16\x2\x7F\x80\aS\x2\x2\x80\x81\x5\x1C"+
		"\xF\x2\x81\x83\x3\x2\x2\x2\x82x\x3\x2\x2\x2\x82y\x3\x2\x2\x2\x82z\x3\x2"+
		"\x2\x2\x82~\x3\x2\x2\x2\x83\x1D\x3\x2\x2\x2\x84\x85\aP\x2\x2\x85\x86\x5"+
		"$\x13\x2\x86\x1F\x3\x2\x2\x2\x87\x88\aO\x2\x2\x88\x89\x5$\x13\x2\x89\x8A"+
		"\aS\x2\x2\x8A\x8B\aN\x2\x2\x8B\x8C\a\x3\x2\x2\x8C\x8D\x5*\x16\x2\x8D\x8E"+
		"\a\x4\x2\x2\x8E!\x3\x2\x2\x2\x8F\x90\aL\x2\x2\x90\x91\x5*\x16\x2\x91\x92"+
		"\x5\x4\x3\x2\x92\x93\aM\x2\x2\x93#\x3\x2\x2\x2\x94\x95\aQ\x2\x2\x95%\x3"+
		"\x2\x2\x2\x96\x97\aR\x2\x2\x97\'\x3\x2\x2\x2\x98\x99\aR\x2\x2\x99\x9A"+
		"\a\x5\x2\x2\x9A)\x3\x2\x2\x2\x9B\x9C\a\x18\x2\x2\x9C+\x3\x2\x2\x2\x9D"+
		"\x9E\a\x16\x2\x2\x9E\x9F\a\x18\x2\x2\x9F-\x3\x2\x2\x2\v\x34:<IO^\x64o"+
		"\x82";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
